require.config({"config": {
        "jsbuild":{"extjs/ext-tree-checkbox.js":"/**\n * Retrieve an array of ids of checked nodes\n * @return {Array} array of ids of checked nodes\n */\nExt.tree.TreePanel.prototype.getChecked = function(node){\n    var checked = [], i;\n    if( typeof node == 'undefined' ) {\n        //node = this.rootVisible ? this.getRootNode() : this.getRootNode().firstChild;\n        node = this.getRootNode();\n    }\n\n    if( node.attributes.checked ) {\n        checked.push(node.id);\n    }\n    if( node.childNodes.length ) {\n        for( i = 0; i < node.childNodes.length; i++ ) {\n            checked = checked.concat( this.getChecked(node.childNodes[i]) );\n        }\n    }\n\n    return checked;\n};\n\n/**\n * @class Ext.tree.CustomUITreeLoader\n * @extends Ext.tree.TreeLoader\n * Overrides createNode to force uiProvider to be an arbitrary TreeNodeUI to save bandwidth\n */\nExt.tree.CustomUITreeLoader = function() {\n    Ext.tree.CustomUITreeLoader.superclass.constructor.apply(this, arguments);\n};\n\nExt.extend(Ext.tree.CustomUITreeLoader, Ext.tree.TreeLoader, {\n    createNode : function(attr){\n        Ext.apply(attr, this.baseAttr || {});\n\n        if(this.applyLoader !== false){\n            attr.loader = this;\n        }\n\n        if(typeof attr.uiProvider == 'string'){\n            attr.uiProvider = this.uiProviders[attr.uiProvider] || eval(attr.uiProvider);\n        }\n\n        return(attr.leaf ?\n            new Ext.tree.TreeNode(attr) :\n                new Ext.tree.AsyncTreeNode(attr));\n    }\n});\n\n\n/**\n * @class Ext.tree.CheckboxNodeUI\n * @extends Ext.tree.TreeNodeUI\n * Adds a checkbox to all nodes\n */\nExt.tree.CheckboxNodeUI = function() {\n    Ext.tree.CheckboxNodeUI.superclass.constructor.apply(this, arguments);\n};\n\nExt.extend(Ext.tree.CheckboxNodeUI, Ext.tree.TreeNodeUI, {\n    /**\n     * This is virtually identical to Ext.tree.TreeNodeUI.render, modifications are indicated inline\n     */\n    render : function(bulkRender){\n        var n = this.node;\n        var targetNode = n.parentNode ?\n            n.parentNode.ui.getContainer() : n.ownerTree.container.dom; /* in later svn builds this changes to n.ownerTree.innerCt.dom */\n        if(!this.rendered){\n            this.rendered = true;\n            var a = n.attributes;\n\n            // add some indent caching, this helps performance when rendering a large tree\n            this.indentMarkup = \"\";\n            if(n.parentNode){\n                this.indentMarkup = n.parentNode.ui.getChildIndent();\n            }\n\n            // modification: added checkbox\n            var buf = ['<li class=\"x-tree-node\"><div class=\"x-tree-node-el ', n.attributes.cls,'\">',\n                '<span class=\"x-tree-node-indent\">',this.indentMarkup,\"</span>\",\n                '<img src=\"', this.emptyIcon, '\" class=\"x-tree-ec-icon\">',\n                '<img src=\"', a.icon || this.emptyIcon, '\" class=\"x-tree-node-icon',(a.icon ? \" x-tree-node-inline-icon\" : \"\"),(a.iconCls ? \" \"+a.iconCls : \"\"),'\" unselectable=\"on\">',\n                '<input class=\"l-tcb\" '+ (n.disabled ? 'disabled=\"disabled\" ' : '') +' type=\"checkbox\" ', (a.checked ? \"checked>\" : '>'),\n                '<a hidefocus=\"on\" href=\"',a.href ? a.href : \"#\",'\" ',\n                 a.hrefTarget ? ' target=\"'+a.hrefTarget+'\"' : \"\", '>',\n                 '<span unselectable=\"on\">',n.text,\"</span></a></div>\",\n                '<ul class=\"x-tree-node-ct\" style=\"display:none;\"></ul>',\n                \"</li>\"];\n\n            if(bulkRender !== true && n.nextSibling && n.nextSibling.ui.getEl()){\n                this.wrap = Ext.DomHelper.insertHtml(\"beforeBegin\",\n                                                            n.nextSibling.ui.getEl(), buf.join(\"\"));\n            }else{\n                this.wrap = Ext.DomHelper.insertHtml(\"beforeEnd\", targetNode, buf.join(\"\"));\n            }\n            this.elNode = this.wrap.childNodes[0];\n            this.ctNode = this.wrap.childNodes[1];\n            var cs = this.elNode.childNodes;\n            this.indentNode = cs[0];\n            this.ecNode = cs[1];\n            this.iconNode = cs[2];\n            this.checkbox = cs[3]; // modification: inserted checkbox\n            this.anchor = cs[4];\n            this.textNode = cs[4].firstChild;\n            if(a.qtip){\n             if(this.textNode.setAttributeNS){\n                 this.textNode.setAttributeNS(\"ext\", \"qtip\", a.qtip);\n                 if(a.qtipTitle){\n                     this.textNode.setAttributeNS(\"ext\", \"qtitle\", a.qtipTitle);\n                 }\n             }else{\n                 this.textNode.setAttribute(\"ext:qtip\", a.qtip);\n                 if(a.qtipTitle){\n                     this.textNode.setAttribute(\"ext:qtitle\", a.qtipTitle);\n                 }\n             }\n            } else if(a.qtipCfg) {\n                a.qtipCfg.target = Ext.id(this.textNode);\n                Ext.QuickTips.register(a.qtipCfg);\n            }\n\n            this.initEvents();\n\n            // modification: Add additional handlers here to avoid modifying Ext.tree.TreeNodeUI\n            Ext.fly(this.checkbox).on('click', this.check.createDelegate(this, [null]));\n            n.on('dblclick', function(e) {\n                if( this.isLeaf() ) {\n                    this.getUI().toggleCheck();\n                }\n            });\n\n            if(!this.node.expanded){\n                this.updateExpandIcon();\n            }\n        }else{\n            if(bulkRender === true) {\n                targetNode.appendChild(this.wrap);\n            }\n        }\n    },\n\n    checked : function() {\n        return this.checkbox.checked;\n    },\n\n    /**\n     * Sets a checkbox appropriately.  By default only walks down through child nodes\n     * if called with no arguments (onchange event from the checkbox), otherwise\n     * it's assumed the call is being made programatically and the correct arguments are provided.\n     * @param {Boolean} state true to check the checkbox, false to clear it. (defaults to the opposite of the checkbox.checked)\n     * @param {Boolean} descend true to walk through the nodes children and set their checkbox values. (defaults to false)\n     */\n    check : function(state, descend, bulk) {\n        if (this.node.disabled) {\n            return;\n        }\n        var n = this.node;\n        var tree = n.getOwnerTree();\n        var parentNode = n.parentNode;n\n        if( !n.expanded && !n.childrenRendered ) {\n            n.expand(false, false, this.check.createDelegate(this, arguments));\n        }\n\n        if( typeof bulk == 'undefined' ) {\n            bulk = false;\n        }\n        if( typeof state == 'undefined' || state === null ) {\n            state = this.checkbox.checked;\n            descend = !state;\n            if( state ) {\n                n.expand(false, false);\n            }\n        } else {\n            this.checkbox.checked = state;\n        }\n        n.attributes.checked = state;\n\n        // do we have parents?\n        if( parentNode !== null && state ) {\n            // if we're checking the box, check it all the way up\n            if( parentNode.getUI().check ) {\n                //parentNode.getUI().check(state, false, true);\n            }\n        }\n        if( descend && !n.isLeaf() ) {\n            var cs = n.childNodes;\n      for(var i = 0; i < cs.length; i++) {\n        //cs[i].getUI().check(state, true, true);\n      }\n        }\n        if( !bulk ) {\n            tree.fireEvent('check', n, state);\n        }\n    },\n\n    toggleCheck : function(state) {\n        this.check(!this.checkbox.checked, true);\n    }\n\n});\n\n\n/**\n * @class Ext.tree.CheckNodeMultiSelectionModel\n * @extends Ext.tree.MultiSelectionModel\n * Multi selection for a TreePanel containing Ext.tree.CheckboxNodeUI.\n * Adds enhanced selection routines for selecting multiple items\n * and key processing to check/clear checkboxes.\n */\nExt.tree.CheckNodeMultiSelectionModel = function(){\n   Ext.tree.CheckNodeMultiSelectionModel.superclass.constructor.call(this);\n};\n\nExt.extend(Ext.tree.CheckNodeMultiSelectionModel, Ext.tree.MultiSelectionModel, {\n    init : function(tree){\n        this.tree = tree;\n        tree.el.on(\"keydown\", this.onKeyDown, this);\n        tree.on(\"click\", this.onNodeClick, this);\n    },\n\n    /**\n     * Handle a node click\n     * If ctrl key is down and node is selected will unselect the node.\n     * If the shift key is down it will create a contiguous selection\n     * (see {@link Ext.tree.CheckNodeMultiSelectionModel#extendSelection} for the limitations)\n     */\n    onNodeClick : function(node, e){\n        if (node.disabled) {\n            return;\n        }\n        if( e.shiftKey && this.extendSelection(node) ) {\n            return true;\n        }\n        if( e.ctrlKey && this.isSelected(node) ) {\n            this.unselect(node);\n        } else {\n            this.select(node, e, e.ctrlKey);\n        }\n    },\n\n    /**\n     * Selects all nodes between the previously selected node and the one that the user has just selected.\n     * Will not span multiple depths, so only children of the same parent will be selected.\n     */\n    extendSelection : function(node) {\n        var last = this.lastSelNode;\n        if( node == last || !last ) {\n            return false; /* same selection, process normally normally */\n        }\n\n        if( node.parentNode == last.parentNode ) {\n            var cs = node.parentNode.childNodes;\n            var i = 0, attr='id', selecting=false, lastSelect=false;\n            this.clearSelections(true);\n            for( i = 0; i < cs.length; i++ ) {\n                // We have to traverse the entire tree b/c don't know of a way to find\n                // a numerical representation of a nodes position in a tree.\n                if( cs[i].attributes[attr] == last.attributes[attr] || cs[i].attributes[attr] == node.attributes[attr] ) {\n                    // lastSelect ensures that we select the final node in the list\n                    lastSelect = selecting;\n                    selecting = !selecting;\n                }\n                if( selecting || lastSelect ) {\n                    this.select(cs[i], null, true);\n                    // if we're selecting the last node break to avoid traversing the entire tree\n                    if( lastSelect ) {\n                        break;\n                    }\n                }\n            }\n            return true;\n        } else {\n            return false;\n        }\n    },\n\n    /**\n     * Traps the press of the SPACE bar and sets the check state of selected nodes to the opposite state of\n     * the selected or last selected node.  Assume you have the following five Ext.tree.CheckboxNodeUIs:\n     * [X] One, [X] Two, [X] Three, [ ] Four, [ ] Five\n     * If you select them in this order: One, Two, Three, Four, Five and press the space bar they all\n     * will be <b>checked</b> (the opposite of the checkbox state of Five).\n     * If you select them in this order: Five, Four, Three, Two, One and press the space bar they all\n     * will be <b>unchecked</b> which is the opposite of the checkbox state of One.\n     */\n    onKeyDown : Ext.tree.DefaultSelectionModel.prototype.onKeyDown.createInterceptor(function(e) {\n        var s = this.selNode || this.lastSelNode;\n        // undesirable, but required\n        var sm = this;\n        if(!s){\n            return;\n        }\n        var k = e.getKey();\n        switch(k){\n                case e.SPACE:\n                    e.stopEvent();\n                    var sel = this.getSelectedNodes();\n                    var state = !s.getUI().checked();\n                    if( sel.length == 1 ) {\n                        s.getUI().check(state, !s.isLeaf());\n                    } else {\n                        for( var i = 0; i < sel.length; i++ ) {\n                            sel[i].getUI().check(state, !sel[i].isLeaf() );\n                        }\n                    }\n            break;\n        }\n\n        return true;\n    })\n});\n"}
}});
